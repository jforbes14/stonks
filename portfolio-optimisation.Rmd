---
title: "portfolio-optimisation"
author: "Jeremy Forbes"
date: "04/07/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

## Useful packages

```{r, echo=FALSE}
library(tidyquant)
library(tidyverse)
```

## Load portfolio

Currently I have:
- NDQ.AX
- A200.AX
- ASIA.AX

```{r}
tickers = c(
  'NDQ.AX'
  , 'A200.AX'
  , 'ASIA.AX'
  , 'MOAT.AX'
  , 'F100.AX'
  , 'HACK.AX'
  # , 'GGUS.AX'
  # , 'ETPMPD.AX'
  # , 'QRE.AX'
  # , 'MVR.AX'
  # , 'MVE.AX'
  ) %>%
  sort()
```

Function to get daily prices

```{r}
get_prices <- function(ticker, from="1900-01-01", to=Sys.Date()) {
  x <- getSymbols(ticker,
                  src = 'yahoo',
                  from="1900-01-01", 
                  to=Sys.Date(),
                  auto.assign = FALSE
                  ) %>% as.data.frame()
  colnames(x) <- c('Open', 'High', 'Low', 'Close', 'Volume', 'Adjusted')
  # x$MidPrice <- (x$High + x$Low)/2
  extract <- data.frame(ticker = ticker, date = rownames(x), price = x$Adjusted) %>% 
    fill(price, .direction = "up")
  return(extract)
}
```

Load all prices into a long dataframe

```{r}
remove(prices_df)
for (ticker in tickers) {
  prc = get_prices(ticker)
  if (exists("prices_df")) {
    prices_df = prices_df %>% 
      bind_rows(prc)
  } else {
    prices_df = prc
  }
}

prices_df <- prices_df %>% 
  mutate(date = as.Date(date))

prices_df %>% summary()
```

## Compute daily returns

```{r}
daily_returns <- prices_df %>%
  group_by(ticker) %>% 
  arrange(date) %>% 
  mutate(return = (price - lag(price, 1))/lag(price, 1),
         log_return = log(price) -log(lag(price, 1)))
```

## Compute mean returns and covariance matrix

First create a data frame of prices for the same dates

```{r}
valid_dates <- daily_returns %>% 
  filter(!is.na(return)) %>% 
  group_by(date) %>% 
  summarise(n = n()) %>% 
  filter(n == length(tickers)) %>% 
  select(date)
```

```{r}
portfolio_data <- daily_returns %>% 
  filter(date %in% valid_dates$date) %>% 
  select(-c(price, return)) %>% 
  spread(key = ticker, value = log_return) %>% 
  select(-date)
```

```{r}
# Daily return
mean_daily_returns <- colMeans(portfolio_data)

# Annualised
mean_returns <- (mean_daily_returns + 1)^252 - 1

# Covariance for daily returns, annualised as there are 252 business days
cov_returns <- cov(portfolio_data) * 252
```

## Global minimum variance

```{r}
one_vec = rep(1, length(tickers))
cov_returns_inv = solve(cov_returns)
top.mat = cov_returns_inv%*%one_vec
bot.val = as.numeric((t(one_vec)%*%cov_returns_inv%*%one_vec))
min_var_split = top.mat/bot.val

# Print minmum variance portfolio
mvp = min_var_split[,1]
mvp

# Annual return
mvp_return = (mvp%*%mean_returns)[1,1]
mvp_return

# Annual risk
mvp_variance = as.numeric(t(mvp) %*% cov_returns %*% mvp)
mvp_sigma = mvp_variance %>% sqrt()
mvp_sigma
```


## Global maximum sharpe ratio

```{r}
rf = 0
mean_returns_less_rf = mean_returns - rf
one_vec = rep(1, length(tickers))
cov_returns_inv = solve(cov_returns)
top.mat = cov_returns_inv%*%one_vec
bot.val = as.numeric(t(one_vec)%*%top.mat)
op = top.mat[,1]/bot.val

# Optimal portfolio
op

# Annual return
op_return = (op%*%mean_returns)[1,1]
op_return

# Annual risk
op_variance = as.numeric(t(op) %*% cov_returns %*% op)
op_sigma = op_variance %>% sqrt()
op_sigma
```


## Random portfolio splits

```{r}
random_splits <- function(tickers, n=1000000) {
  random_wts <- matrix(runif(n*length(tickers)), ncol=length(tickers))
  colnames(random_wts) = tickers
  standardised_wts <- random_wts / rowSums(random_wts)
  rounded_wts <- round(standardised_wts, 2)
  
  # Discard any that don't add to 1 exactly
  out <- rounded_wts[rowSums(rounded_wts) == 1,] %>% 
    unique()
  
  return(out)
}
```


```{r}
# candidate_wts = grid_fn(tickers, precision=0.1)
candidate_wts = random_splits(tickers)
candidate_wts %>% dim
```

## Calculate returns and risk

```{r}
# Annual returns
port_returns <- (candidate_wts %*% mean_daily_returns + 1)^252 - 1
```

```{r}
# Annual risk
compute_risk <- function(wts) {
  return(sqrt(t(wts) %*% (cov_returns %*% wts)))
}

port_risk <- candidate_wts %>% apply(1,compute_risk)
```

```{r}
# Combine into data frame
df <- data_frame(
  return = port_returns %>% as.vector(),
  risk = port_risk %>% as.vector()
) %>% 
  mutate(sharpe_ratio = return/risk) %>% 
  bind_cols(candidate_wts %>% as.data.frame())
```

```{r}
# Maximum sharpe ratio
df %>% 
  arrange(desc(sharpe_ratio)) %>% 
  head()
```


```{r}
# Minimum risk
df %>% 
  arrange(risk) %>% 
  head()
```


## Take the best 100 portfolio options, and average the splits for each share

```{r}
df %>% 
  arrange(desc(sharpe_ratio)) %>% 
  head(100) %>% 
  colMeans() %>% 
  round(2)
```



## Plot

```{r}
df %>% 
  ggplot(aes(x=risk, y=return, col=sharpe_ratio)) +
  geom_point(size=0.25) +
  scale_color_gradient(low = 'purple', high = 'orange')
```


